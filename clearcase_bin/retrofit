#!/bin/sh

lines=`cat $0 | wc -l`
lines=`expr $lines - 14`
tail -$lines $0 > /tmp/runperl$$
echo "# $0 $*" >> /tmp/runperl$$
while [ $# -ne 0 ]
do
    line=$1
    shift
    totline="$totline\`$line"
done
exec perl /tmp/runperl$$ $0 $totline

# Perl begins here.

# This script converts a view created with "makenew" or "makebug" on an older 
# release to a view geared to the new release.

unlink($0);

# strippath separates a fully-expanded filename into its path and file
# parts.  If the fully-expanded filename does not have a path componenent, a
# NULL string is returned as the path.  The returned value is a list with the
# filename first and the path second, so that you can ignore the path if
# you like:
#           ($file) = &strippath($bigname);

sub strippath
{
    local($fullname) = @_;

    $fullname =~ m|^(.*/)?([^/]*)$|;
    ($path,$file) = ($1,$2);
    return($file,$path);
}

($0) = &strippath(shift);

$args = "@ARGV";
$args =~ s/^.//;
@ARGV = split('\`',$args);

# The real script begins here

require "newgetopt.pl";

$usage = "\nUSAGE: retrofit -from (new | bug) -to (new | bug) view_tag\n";

&NGetOpt("from=s","to=s");

$tag = shift;

if (!defined($tag))
{
    print STDERR "No view tag specified.\n";
    print STDERR "$usage\n";
    exit(-1);
}

if ((!defined($opt_from)) || (($opt_from ne "new") && ($opt_from ne "bug")))
{
    print STDERR "Please specify a \"from\" type of either \"new\" or \"bug\".\n";
    print STDERR "$usage\n";
    exit(-1);
}

if ((!defined($opt_to)) || (($opt_to ne "new") && ($opt_to ne "bug")))
{
    print STDERR "Please specify a \"to\" type of either \"new\" or \"bug\".\n";
    print STDERR "$usage\n";
    exit(-1);
}

if (@ARGV > 1)
{
    print STDERR "Too many arguments specified.\n";
    print STDERR "$usage\n";
    exit(-1);
}

# Check if the transition is valid
if (($opt_from eq "new") && ($opt_to eq "bug"))
{
    print STDERR <<"EOF";
No processing is required to retrofit a "new" view to a "bug" view.
It is already set up to see the bugline.
EOF
    exit(0);
}

if (($opt_from eq "bug") && ($opt_to eq "new"))
{
    print STDERR <<"EOF";

It is not possible to convert an old "bug" view to a new "new" view.

If you would like to do new development work, you will have to create
a new view using "makenew", then merge your work from your old branch
to the new one.
EOF
    exit(0);
}

# Get the config spec of the view
open(CS,"cleartool catcs -tag $tag|")
    || die "Unable to get the config spec of view \"$tag\": $!\n";
@spec = <CS>;
close(CS);

# First, check if there is a comment as the first line.  If there isn't, this 
# spec is strange and we have to bail.
if ($spec[0] !~ /^#/)
{
    print STDERR <<"EOF";

This view's config spec is not formatted normally.  It probably wasn't
created wth "makenew" or "makebug".  Please contact Sean Ahern to see
if this view can be converted.
EOF
    exit(0);
}

# Get the name of the new branch.
open(NB,"/home/meshtv/next_release_branch");
($full_new_release_branch,$new_release_label) = (<NB> =~ /^(\S+)\s+(\S+)/);
close(NB);
($new_release_branch) = ($full_new_release_branch =~ m|^/main/(.*)$|);

# Get the name of the current branch
open(NB,"/home/meshtv/current_release_branch");
($full_current_release_branch,$current_release_label) = (<NB> =~ /^(\S+)\s+(\S+)/);
close(NB);
($current_release_branch) = ($full_current_release_branch =~ m|^/main/(.*)$|);
$current_release_branch = "" if (!defined($current_release_branch));

print STDERR "Converting view \"$tag\"...\n";

# See if this is a "mainline" view
if ($spec[0] =~ /^#.*to see/)
{
    print STDERR "\nThis looks like a main view of the ${opt_from}line.\n";
    if ($opt_to eq "bug")
    {
        @config_spec = (
            "# View configured to see the $current_release_branch branch",
            "element * CHECKEDOUT",
            "element * /main/$current_release_branch/LATEST",
            "element * /main/LATEST -mkbranch $current_release_branch"
        );
    } else {
        @config_spec = (
            "# View configured to see the $new_release_branch branch",
            "element * CHECKEDOUT",
            "element * /main/$new_release_branch/LATEST",
            "element * /main/$current_release_label -mkbranch $new_release_branch",
            "element * /main/LATEST -mkbranch $new_release_branch"
        );
    }
} else {
    print STDERR "\nThis looks like a development view of the ${opt_from}line.\n";
    if ($spec[3] =~ /-mkbranch\s+(\S+)/)
    {
        $branch = $1;
        print STDERR "Development is being done on the \"$branch\" branch.\n";
    } else {
        print STDERR "\nI was unable to determine what branch work was done on.\n";
        exit(-1);
    }
    if ($opt_to eq "bug")
    {
        @config_spec = (
            "# View configured for bugfix work on branch $branch",
            "element * CHECKEDOUT",
            "element * .../$branch/LATEST",
            "element * /main/$current_release_branch/LATEST -mkbranch $branch",
            "element * /main/LATEST -mkbranch $current_release_branch"
        );
    } else {
        @config_spec = (
            "# View configured for new work on branch $branch",
            "element * CHECKEDOUT",
            "element * .../$branch/LATEST",
            "element * /main/$new_release_branch/LATEST -mkbranch $branch",
            "element * /main/$current_release_label -mkbranch $new_release_branch",
            "element * /main/LATEST -mkbranch $new_release_branch"
        );
    }
}

# If we're on a new branch, we need to check for lock files and put a 
# "ReleaseBranch" attribute on them.

if (($opt_to eq "new") && ($branch ne ""))
{
    print STDERR "Checking for \"lock\" files on branch \"$branch\"...\n";

    # Look for all elements that have an attribute of type SingleBranchName
    system("cleartool startview $tag");
    $att_elements = `cleartool find /view/$tag/MeshTV_vob -element "attype(SingleBranchName)" -print`;
    if ($att_elements !~ /^\s*$/)
    {
        @att_elements = split('\n',$att_elements);

        # Check for the $branch value in each of these elements.
        foreach $element (@att_elements)
        {
            $value = `cleartool desc -fmt "%NS[SingleBranchName]a" $element`;
            $value =~ s/"//g;
            if ($value eq $branch)
            {
                $status = system("cleartool mkattr ReleaseBranch \\\"$new_release_branch\\\" $element");
                $status /= 256;
                if ($status != 0)
                {
                    print STDERR <<"EOF";

ERROR: Unable to put a "ReleaseBranch" attribute on file $element.  Let Sean 
Ahern know about this.  This view cannot be automatically converted.
EOF
                    exit(1);
                }
            }
        }
    }
}

$config_spec_file = "/tmp/config_spec$$";
if (open(CONFIG_SPEC,">$config_spec_file") == 0)
{
    print STDERR <<"EOF";

I was unable to create a temporary file to write the config spec to.

You will have to manually set the config spec to be:

EOF
    foreach $line (@config_spec)
    {
        print "    $line\n"
    }
    exit(-1);
}

foreach $line (@config_spec)
{
    print CONFIG_SPEC "$line\n"
}
close(CONFIG_SPEC);

$system = system("cleartool setcs -tag $tag $config_spec_file");
$system /= 256;
if ($system != 0)
{
    print STDERR <<"EOF";
An error occurred while setting the config spec for the view
"$tag".  You will have to manually set the config spec to be:

EOF

    foreach $line (@config_spec)
    {
        print "    $line\n"
    }
    
    unlink($config_spec_file);
    exit(-1);
}

unlink($config_spec_file);

print STDERR <<"EOF";

Your view "$tag" has now been retrofitted.

Note that you may have to do a "make clean" and then a "make" to
ensure that you have a correct build of those files you're seeing from
the ${opt_to}line.

EOF
