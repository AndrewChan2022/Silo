#!/usr/local/bin/perl

# This script locks the new branch to the current user so that no one else
# can modify the new branch.  This is useful for doing merges.

sub dieout
{
    my ($val, $msg) = @_;

    if ($msg =~ /\n$/)
    {
        warn $msg;
    } else {
        warn "$msg: $!\n";
    }
    exit $val;
}

$user = shift;

# format_array prints out an array in an 'ls' type form.  It basically
# formats the contents of an array neatly, based on the length of the
# longest element in the array.
sub format_array
{
    local(@a) = @_;
    local($max,$col);

    $max = 0;

    foreach (@a)
    {
        $max = ($max<length($_))?length($_):$max;
    }

    $col = 0;
    foreach (@a)
    {
        if ($col+$max >= 75)
        {
            print "\n";
            $col = 0;
        }

        $col += $max+1;
        print "$_ ";
        if (length($_) < $max)
        {
            print " " x ($max - length($_));
        }
    }
    print "\n";
}

# Get the name of the new branch.
open(NB,"/home/meshtv/next_release_branch");
($full_new_release_branch,$new_release_label) = (<NB> =~ /^(\S+)\s+(\S+)/);
close(NB);
($new_release_branch) = ($full_new_release_branch =~ m|^/main/(.*)$|);

# Print out some help
sub help
{
    print <<"EOF";
USAGE: locknew -ls | -help
    -ls         Lists any lock on the "$new_release_branch" branch.
    -help       Prints this help message.
EOF
}

# Process the options including error checking on the options.
require "newgetopt.pl";
&NGetOpt("ls","help","nospin");

if ($opt_help)
{
    &help();
    exit(0);
}

if ($opt_ls)
{
    $opt_list = 1;
}

# The options are alright.  Now check to see who we are.
# We have to be meshtv.
$cleartool = "/usr/atria/bin/cleartool";
$who = `/usr/local/bin/whoami`;
chop($who);

# We must be meshtv to have this stuff work.
if ($who ne "meshtv")
{
    # We're not meshtv, so either we're not setuid or we didn't use ssh.
    print STDERR <<"EOF";
This script is not set up correctly.  Contact
Sean Ahern (ahern\@llnl.gov) to see if he can figure out why.
EOF
    exit(-1);
}

# Make sure that we have a path into the VOB.
print STDERR "Checking lock status...\n";
$view = `$cleartool lsview 'meshtv_VOBowner_new'`;
if ($view !~ /^\*/)
{
    #system("$cleartool endview meshtv_VOBowner_new");
    $status = system("$cleartool startview meshtv_VOBowner_new");
    $status /= 256;
    dieout(-2,"Unable to start the meshtv_VOBowner_bug view.\n") if ($status != 0);
}
$status = chdir("/view/meshtv_VOBowner_new/MeshTV_vob");
dieout(-2,"Unable to chdir to the MeshTV VOB ($status).\n") if ($status != 1);

# Get the status of any lock that exists.
$lock_owner = "";
$users = "";
$users = `$cleartool lslock -fmt "%c" brtype:$new_release_branch`;
chop($users);
($lock_owner) = ($users =~ /^Locked except for users: (\w*)/);
$* = 1;
$comment = $users;
$comment =~ s/^Locked except for users:.*$//;
$comment =~ s/^\s*//;

# If we're just listing, output appropriate information.
if ($opt_list)
{
    if ($lock_owner =~ /^\s*$/)
    {
        print STDERR "The \"$new_release_branch\" branch is not locked.\n";
        exit(0);
    } else
    {
        print STDERR "The \"$new_release_branch\" branch is locked by $lock_owner.\n";
        print STDERR "Comment for lock:\n$comment\n";
        exit(1);
    }
}

# Attempt to lock the new release branch.

# If the lock owner is non-null, then it's already locked.
if ($lock_owner !~ /^\s*$/)
{
    if ($lock_owner eq $user)
    {
        print STDERR <<"EOF";
You already have the \"$new_release_branch\" branch locked.  Your comment:
$comment
EOF
        exit(2);
    } else
    {
        print STDERR <<"EOF";

The "$new_release_branch" branch is already locked by $lock_owner.  You may not
modify the "$new_release_branch" branch until $lock_owner unlocks it.  If you
know for sure that $lock_owner is done with the "$new_release_branch" branch,
you may forcably remove the lock by calling "unlocknew -force" and then locking
it yourself.

The comment for ${lock_owner}'s lock is:
$comment

EOF
        if ($opt_nospin)
        {
            exit(1);
        } else {
            print STDERR "Would you like to poll for the lock? [Y/(N)]: ";
            $query = <STDIN>;
            if ($query =~ /^y/i)
            {
                exec("spinlock new $user");
            } else {
                exit(1);
            }
        }
    }
}

# Everything's fine, let's try and lock the branch.
print STDERR "Comment for the lock on $new_release_branch: (\".\" or ^D ends comment)\n";
$comment = "";
while(<STDIN>)
{
    last if (/^\.$/);
    $comment .= $_;
}
chop($comment);

# Check for a valid comment
if ($comment =~ /^\s*$/)
{
    print STDERR "You need to give a non-blank comment.\n";
    exit(-3);
}

# Save the comment in a temp file since it might be long and/or contain
# shell meta characters.
open (TMP, "> /tmp/lock_main.$$") || &dieout(-2,"cannot save comment to a temp file");
print TMP $comment;
close (TMP);

$status = system("$cleartool lock -cfile /tmp/lock_main.$$ -nusers $user,meshtv brtype:$new_release_branch");
system "/bin/rm","-f","/tmp/lock_main.$$";
$status /= 256;
if ($status != 0)
{
    print STDERR "An error occurred while locking \"$new_release_branch\": $!\n";
    exit($status);
} else
{
    print STDERR "Branch \"$new_release_branch\" locked successfully\n";
    exit(4);
}
