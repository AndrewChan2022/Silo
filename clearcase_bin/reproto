#!/usr/local/bin/perl -w
require 5.003;
$|=1;

# Copyright (C) 1997 The Regents of the University of California
#		     All rights reserved.


### Programmer
#
#	Robb Matzke, 11 Apr 1997


### Purposes
#
# 	- Converts K&R function declarations to ANSI-C if any K&R
#	  declarations exist.
#
#	- Manages the scope of functions by adding or removing the
#	  `static' keyword from the prototype(s) and the definition.
#
#	- Keeps prototypes up to date when function argument names
#	  change or functions are deleted or added.


### Usage
#
# * Prepare the `.c' files...
#
#    First, prepare your `.c' files by grouping any function
#    prototypes that appear in that file in a single block with no
#    intervening blank lines.  Then immediately precede that block
#    with a comment like
#
#	/* PRIVATE PROTOTYPES -- machine generated */
#
#    The only important part is that this comment is the only thing on
#    the line and that it begins with PRIVATE PROTOTYPES or just
#    PROTOTYPES.  The amount of white space doesn't matter.
#
#    Also make sure that your function definitions begin in the first
#    column.  The return type can be on the previous line but it also
#    must start in the first column.
#
# * Prepare the `.h' files
#
#    You will need at least one `.h' file that has the prototypes for
#    the public functions.  The current version of this program emits
#    all public prototypes to a single file.  Add a comment like
#
#	/* PROTOTYPES */
#
#    on a line by itself and followed by a blank line.  The public
#    prototypes will be inserted at this point.
#
# * Process the files
#
#    Give the names of all your `.c' files on the command line.
#    Include the `.h' file with the /*PROTOTYPES*/ comment somewhere
#    in that list (it doesn't hurt to include all your `.h' files).
#
#    You might want to set `$careful' to a non-zero value the first
#    time you try this and the output files will not be copied over
#    the old `.c' files.  If you set $careful, the output is in files
#    ending with `.pass3'.  If $careful is zero, then the source files
#    are renamed by appending `.contrib' to the name.


### Bugs
#
# * All the public prototypes go to each header file with a
#   /*PROTOTYPES*/ comment.  It would be nice if the user had more
#   control.
#
# * The function declaration algorithm relies on indentation, so
#   function must start in column one and other things in column one
#   sometimes confuse it.  Fortunately it's usually able to recover.
#
# * When checking to see if a function is used in other files, the
#   check is textual.  If the function only appears in the body of a
#   macro then that function would appear to be private and thus be
#   declared `static'.  To prevent this, add an `extern' prototype in
#   some other source file (or you could just put the name in a
#   comment in some other file).


### Modifications
#
# Robb Matzke, 22 Apr 1997
# The mtime for the .c files is increased only if the file actually
# changed.
#
# Robb Matzke, 3 Jun 1997
# Changed so prototype lines don't end with a space character when
# the prototype spans more then one line.
#


# User options... change these to suite your needs.
$careful = 0;			#don't overwrite source files
$verbose = 0;			#print extra debug info
$Width = 75;			#try not to exceed this many columns of output


##############################################################################
#		    No more user-serviceable parts			     #
##############################################################################






%Prototype = ();		#Prototypes by `file:func'
%Public = ();			#List of public functions `file:func'
%Where = ();			#Original line number for `file:func'
$File = "";			#Current file name
$Where = $0;			#Current position as `file:line'
$Pass = 0;			#Current pass number

#
# Set the pass number
#
sub pass {
   ($Pass) = @_;
   print STDERR "Pass $Pass...\n";
}

#
# Some people have really ugly white-space styles.  We ignore them
# and re-format according to the MeshTV style guide.
#
sub standardize {
   local ($_) = @_;

   # Get rid of line-feeds and extra white space
   s/\s+/ /gm; 			#duplicate white space
   s/([\*\(\],])\s+/$1/g; 	#space after special characters
   s/\s+([\*\)\[,])/$1/g; 	#space before special characters

   # Insert standard spacing
   s/(\w)\*/$1 */g;		#space after a word and before *
   s/,/, /g;			#space after a comma
   s/([^\(\s])\(/$1 (/g;	#space befire first left paren

   return $_;
}

#
# Parses K&R-style prototype declarations.  The input is a string
# containing zero or more semicolon-separated declaration statements
# like `int x, *y, *z[8]; float A;'
#
# The output is a hash indexed by parameter name where the values are
# suitable to be plugged directly into the ANSI-C function parameter
# list.  The above input would return
#
#	( x => "int x",  y => "int *y",  z => "int *z[8]")
#	
sub parse_argtypes {
   my ($knr) = @_;		#the K&R parameter declarations
   my (%arg);			#the type of each parameter
   my ($stmt);			#each decl statement
   my ($name);			#argument name
   my ($ds);			#declaration specifier
   local ($_);

   # Remove comments
   $knr =~ s/\/\*.*?\*\///g;
   
   # process each statement
   for $stmt (split /;/, $knr) {
      next unless $stmt =~ /\S/;

      # the declaration specifier
      if ($stmt =~ /^\s*((struct|union|enum)\s+[a-zA-Z_]\w*)/) {
	 # a named structure, union, or enum
	 $ds = $1;
	 $stmt = $';

      } elsif ($stmt=~/^(\s*(const|volatile|void|
			     signed|unsigned|short|long))+/x) {
	 # a type qualifier
	 $ds = $1;
	 $stmt = $';

	 if ($stmt =~ /^\s*(char|int|long)/) {
	    # an integral type specifier
	    $ds .= " " . $1;
	    $stmt = $';
	 }

      } elsif ($stmt =~ /^\s*([a-zA-Z_]\w*)/) {
	 $ds = $1;
	 $stmt = $';
      } else {
	 die "no declaration specifier in \"$stmt\"";
      }

      # the rest of the statement is the types
      my $arg;
      for $arg (split /,/, $stmt) {
	 $arg =~ s/^\s+//;  #remove leading space
	 $arg =~ s/\s+$//;  #remove trailing space
	 
	 # There should only be one word not counting the ones that
	 # might appear inside `[]'.
	 $_ = $arg;
	 1 while s/\[.*?\]//g; #get rid of `[...]' before we check
	 unless (($name) = /^[^a-zA-Z_]*([a-zA-Z_]\w*)[^a-zA-Z_]*$/) {
	    printf STDERR "$Where: bad K&R declaration: $ds <!> $arg\n";
	    die "cannot continue";
	 }

	 die if exists $arg{$name};
	 $arg{$name} = standardize "$ds $arg";
      }
   }

   return %arg;
}

#
# Given an parameter list possibly followedy by some K&R parameter
# declarations, split the line into two parts: the parameters (without
# the enclosing parentheses) and the K&R parameter decls.  The tricky
# part is that the parameters could be ANSI-C and have embeded parentheses.
#
sub getparams {
   my ($s) = @_;
   my ($params, $knr) = ($s, "");
   local ($_);

   # check if the whole thing is parenthesized by removing (...)
   $_ = '(' . $s; #input doesn't have it
   1 while s/\([^\(]*?\)//;

   if (/\S/) {
      ($params, $knr) = $s =~ /(.*?)\)(.*)/;	# K&R
   } else {
      $params =~ s/\)\s*$//;			# ANSI-C
   }
   $params = "void" unless $params =~ /\S/;		# void for no args
   return ($params, $knr);
}

#
# Given
#
#   1.  The previous line of input from the file
#
#   2.  The current line of input beleived to be a function
#	 declaration.
#
# Returns
#
#   1.  The extra beginning stuff that isn't actually part of the
#	 function definition.
#
#   2.  The return type for the function
#
#   3.  The name of the function.
#
#   4.  The arguments for the function.  The arguments do not include
#	 the left or right parentheses.
#
#   5.  Trailing stuff which isn't part of the function declaration.
#	 This does not inlude the right parenthesis but it does include
#	 the leading curly brace for the body.
#
# If this function determines that it isn't looking at a function
# declaration, then it should return the entire text as the $prev
# return value.
#
sub funcdecl {
   my ($prev, $decl) = @_;	#`prev' is also part of the return value
   my ($rettype, $name, $arglist, $extra) = ("", "", "", ""); #return vals
   my ($is_knr) = 1;
   my ($original_input);

   my ($krntypes); #the K&R-style parameter declaration statements
   local ($_);

   # Is the previous line part of this decl?
   if ($prev =~ /^[a-zA-Z_]/) {
      $decl = $prev . $decl;
      $prev = "";
      $Where = "$File:" . ($.-1);
   }

   # The declaration had better begin with a letter
   return ($prev.$decl) unless $decl =~ /^[a-zA-Z_]/;

   # First, gather all the declaration into a single string.  The declaration
   # ends with the first curly brace or the first semicolon if it appears
   # directly after the first right paren.
   while ($decl!~/\{/ && $decl!~/^[^\)]*\)\s*;/ && ($_=<IN>)) {
      $decl .= $_;
   }
   $original_input = $prev.$decl;

   # If the declaration has a semicolon after the first right paren, then
   # this is a function declaration instead of a function definition.  If
   # this isn't a static declaration, then issue a warning
   # and don't do anything since We do not allow private functions to be
   # non-static and all public function are declared in header files.
   if ($decl =~ /^[^\)]*\)\s*;/) {
      if (1==$Pass && $decl !~ /^static/) {
	 ($name) = $decl =~ /([a-zA-Z_]\w*)\s*\(/;
	 print STDERR "$Where: non-static private declaration for $name\n";
      }
      return $original_input;
   }
   
   # Make sure there isn't any extra stuff that isn't part of the decl.
   if ($decl =~ /\s*\{/) {
      $extra = "{" . $';
      $decl = $`;
   } else {
      die "not a function definition (maybe a forward decl?)";
   }
   $decl = standardize $decl;

   # If there is no type, then it is an int.
   $decl = "int " . $decl if $decl =~ /^[a-zA-Z_]\w*\s*\(/;

   # Get the return type and function name.
   unless (($rettype, $name) = $decl =~ /^\s*(.*?)\s*([a-zA-Z_]\w*)\s*\(/) {
      die "cannot find return type and name";
   }
   $decl = $'; #everything past the `('

   # Get the arguments, or `void' if there are none.
   ($arglist, $knrtypes) = getparams $decl;

   # If the argument is just the word `void' then we're done.
   if ($arglist eq "void") {
      print STDERR "ANSI no arguments" if $verbose;
      if ($knrtypes && 1==$Pass) {
	 print STDERR "$Where: K&R declaration but no parameters\n";
      }
      $is_knr = 0;
      goto done;
   }

   # If the parameter list contains more than just words, then
   # this must be an ANSI declaration.
   @arg = split /,\s*/, $arglist;
   for (@arg) {
      $is_knr = 0 unless /^[a-zA-Z_]\w*$/;
   }
   if (!$is_knr) {
      if ($knrtypes && 1==$Pass) {
	 print STDERR "$Where: mixed ANSI and K&R declaration\n";
	 print STDERR "$Where: (The previous error may have been caused\n";
	 print STDERR "$Where: because something was incorrectly recognized\n";
	 print STDERR "$Where: as a function)\n";
	 print STDERR "  PREV    =$prev\n"      if $verbose;
	 print STDERR "  RETTYPE =$rettype\n"   if $verbose;
	 print STDERR "  NAME    =$name\n"      if $verbose;
	 print STDERR "  ARGS    =$arglist\n"   if $verbose;
	 print STDERR "  KNRTYPES=$knrtypes\n"  if $verbose;
      }
      return $original_input if $knrtypes;
      goto done;
   }

   # Sometimes we use a macro as the argument and that macro expands to
   # all the ANSI-C arguments for the function.
   if (!$knrtypes && $arglist=~/^[A-Z_][A-Z_0-9]*$/) {
      $is_knr = 0;
      goto done;
   }

   # What are the argument types?
   print STDERR "K&R" if $verbose;
   %argtypes = parse_argtypes $knrtypes;
   $arglist = "";
   for (@arg) {
      $arglist .= ", " if $arglist;
      $arglist .= $argtypes{$_} ? $argtypes{$_} : "int $_";
      delete $argtypes{$_};
   }

   # Make sure we used all the K&R-declared arguments
   die "didn't use all the arguments" if keys %argtypes;

 done:
   printf STDERR "%-40s %s\n", "$Where:$name:", $is_knr?"K&R":"ANSI"
       if $verbose;
   return ($prev, $rettype, $name, $arglist, $extra);
}

#
# Given an indent level and an argument list, return a multi-line
# string by splitting the argument list on commas so a line doesn't
# exceed $Width characters unless the single argument would extend
# beyond that limit.  The first line is not indented (the caller does
# that) and the last line is not terminated with a line-feed.
#
sub indented {
   my ($amount, $arglist) = @_;
   my ($s) = ""; #retval
   local ($_);

   my (@args) = split /\s*,\s*/, $arglist;
   my ($cur) = $amount;
   
   while ($_ = shift @args) {
      $_ .= ", " if @args;
      $s .= "\n"." " x ($cur=$amount)
	  if length($_)+$cur>$Width && $cur!=$amount;
      $s .= $_;
      $cur += length;
   }
   $s =~ s/\s+$//mg;

   return $s;
}

#
# Given some text, a function return type, a function name, the
# function arguments (without the parentheses), and some extra
# stuff (often containing the opening curly brace for the function
# body), this function writes the function declaration to the current
# output file.
#
# A prototype is added to the Prototype hash where the key is the
# file name, line number, and function name separated from one another
# by colons.
#
# If $name is missing then we just return the first argument.
#
sub funcout {
   my ($pre, $rettype, $name, $args, $extra) = @_;

   # this isn't a function unless $rettype is defined
   return $pre unless defined $name;

   # output.  Be careful to format the arguments correctly.	
   print OUT $pre, $rettype, "\n", $name, " (";
   print OUT indented 2+length $name, $args;
   print OUT ")\n", $extra;

   # save prototype on the first pass.
   if ($Pass == 1) {
      die "multiply defined function `$name'" if $Prototype{"$File:$name"};
      $Prototype{"$File:$name"} = standardize "$rettype $name ($args);";
      $Where{"$File:$name"} = $Where;
   }

   return "";
}

#
# Returns true if the current line looks like it could be a function
# declaration.
#
sub looks_like_a_func {
   local ($_) = @_;

   if (/^(\*\s*)?[a-zA-Z_]\w*\s*\(/) {
      # A function on a line by itself.
      # Sometimes we have a `*' at the beginning of the line.
      return 1;

   } elsif (/^[a-zA-Z_]/ &&
	    /^(extern|static)?\s*
	     ((signed|unsigned|volatile|const|short|long)\s*)*
	     (char|int|float|double|void)?\s*(\*\s*)*
	     [a-zA-Z_]\w*\s*\(/x) {
      # A type followed by zero or more stars followed by the
      # function name and parameters
      return 1;

   } elsif (/^(struct|union|enum)\s+(\*\s*)*[a-zA-Z_]\w*\s*\(/) {
      # A named structured type followed by zero or more stars
      # followed by the function name and parameters.
      return 1;

   } elsif (/^[a-zA-Z_]\w*\s*(\*\s*)*[a-zA-Z_]\w*\s*\(/) {
      # A name followed by zero or more stars, followed by
      # a function name and argument list.
      return 1;
   }
   return 0;
}


#
# In pass 1, we rewrite files by changing K&R-style function definitions
# to ANSI-C definitions.  No other changes are made.
#
sub pass1 {
   my (@files) = @_;
   local ($_);
   pass 1;

   for $File (@files) {
      next if $File =~ /\.h$/; #skip header files
      my ($out) = "$File.pass1";
      open IN, $File or die "cannot read $File";
      open OUT, "> $out" or die "cannot open $out";

      my ($prev) = "";
      while (<IN>) {
	 $Where = "$File:$.";

	 if (looks_like_a_func $_) {
	    $prev = funcout funcdecl $prev, $_;
	    $_ = "";
	 }
	 print OUT $prev;
	 $prev = $_;
      }
      print OUT $prev;
      close OUT;
      close IN;
   }

   print "Pass 1: ", scalar(keys %Prototype), " functions detected.\n";
}

#
# In pass 2 we try to figure out which functions are private and
# which are public.  This is just a quick textual comparison and is
# prone to problems of names appearing in comments or strings.
# The `Public' hash, indexed by `file:func', is an array of file
# names that reference that function (including the file that
# defines the function).  If a function name appears only when it's
# defined then it is a private function and a record of its existence
# is not added to the %Public hash.
#
sub pass2 {
   my (@files) = @_;
   my ($ident);		# `file:line:func'
   local ($_);
   pass 2;

   # Scan files
   for $File (@files) {
      next if $File =~ /\.h$/; #skip header files
      print STDERR "Scanning $File...\n";
      $_ = `cat $File.pass1`; study;
      for $ident (keys %Prototype) {
	 my ($file, $func) = split /:/, $ident;
	 next if $file eq $File; # we don't care about private references.
	 if (/\b$func\b/m) {
	    unless (exists $Public{$ident}) {
	       push @{$Public{$ident}}, $file;
	    }
	    push @{$Public{$ident}}, $File;
	 }
      }
   }
}

#
# Output private prototypes to the OUT file handle.  Make sure each
# starts with `static'
#
sub private_protos {
   my ($me) = @_;
   my ($ident);

   for $ident (sort keys %Prototype) {
      next if exists $Public{$ident};
      my ($file, $func) = split /:/, $ident;
      next unless $file eq $me;
      next if $func eq "main"; # `main' is never private

      my ($left, $args) = $Prototype{$ident} =~ /^(.*?[a-zA-Z_]\w*\s*\()(.*)/;
      $left = "static " . $left unless $left =~ /^static/;
      print OUT $left, indented length $left, $args;
      print OUT "\n";
   }
   print OUT "\n"; #a blank line at the end of the prototypes
}

#
# In pass 3 we rescan the files and emit prototype information for
# private functions.  We also rewrite the ANSI-C function declarations
# by adding or removing the `static' storage class specifier.
#
# Private prototypes are written after the comment `/*PROTOTYPES*/'
# where ever that might appear on a line by itself.
#
sub pass3 {
   my (@files) = @_;
   local ($_);
   pass 3;

   for $File (@files) {
      next if $File =~ /\.h$/; #skip header files
      print STDERR "Scanning $File...\n";
      my $in = "$File.pass1";
      my $out = "$File.pass3";
      open IN, $in or die "cannot read $in";
      open OUT, "> $out" or die "cannot write to $out";

      my ($wrote_protos) = 0;
      my ($prev) = "";
      while (<IN>) {
	 $Where = "$in:$.";
	 
	 if (/^\s*\/\*\s*(PRIVATE\s+)?PROTOTYPES\b.*\*\/\s*$/) {
	    #
	    # Emit private prototypes for this file
	    #
	    print OUT $prev, $_;
	    while ($_=<IN>) {last if /^\s*$/} # eat the old prototypes
	    private_protos $File;
	    $prev = $_ = "";
	    $wrote_protos++;

	 } elsif (looks_like_a_func $_) {
	    #
	    # Re-emit the function by adding or removing `static'
	    # from its declaration depending on whether the function
	    # was found outside this file.
	    #
	    my ($p, $rettype, $name, $args, $extra) = funcdecl $prev, $_;
	    print OUT $p;
	    if ($name) {
	       
	       # Add or remove the `static' qualifier.
	       my $where = $Where{"$File:$name"};
	       if (($name eq 'main' || $Public{"$File:$name"}) &&
		   $rettype =~ /^static/) {
		  print STDERR "$where: removing `static' from $name\n";
		  $rettype =~ s/^static\s*//;
	       } elsif (($name ne 'main' && !$Public{"$File:$name"}) &&
			$rettype !~ /^static/) {
		  print STDERR "$where: adding `static' to $name\n";
		  $rettype = "static " . $rettype;
	       }
	       funcout "", $rettype, $name, $args, $extra;
	    }
	    $prev = $_ = "";
         }

	 print OUT $prev;
	 $prev = $_;
      }
      print OUT $prev;
      close OUT;
      close IN;

      print STDERR "$File:1: didn't write private prototypes to this file\n"
	  unless $wrote_protos;
   }
}
   
	 
#
# Outputs public prototypes to the header file(s)
#
sub public_protos {
   my (@files) = @_;
   local ($_);

   my $wrote_protos = 0;
   for $File (@files) {
      next unless $File =~ /\.h$/; #only process header files
      open IN, $File or die "cannot read $File";
      my $out = "$File.pass3"; #this is part of the final pass
      open OUT, "> $out" or die "cannot write to $out";

      my $blkno = 0;
      while (<IN>) {
	 if (/^\s*\/\*\s*PROTOTYPES\b.*\*\/\s*$/) {
	    while ($_=<IN>) {last if /^\s*$/} # eat the old prototypes
	    
	    if (0 == $blkno++) {
	       $wrote_protos++;
	       my $prev = "";
	       for (sort keys %Prototype) {
		  my ($file) = split /:/;
		  next unless exists $Public{$_};

		  # new block of prototypes for next file
		  if ($file ne $prev) {
		     print OUT "\n" if $prev;
		     print OUT "/* PROTOTYPES for $file */\n";
		     $prev = $file;
		  }

		  my ($left, $args) =
		      $Prototype{$_} =~ /^(.*?[a-zA-Z_]\w*\s*\()(.*)/;
		  $left =~ s/^static\s*//;
		  print OUT $left, indented length $left, $args;
		  print OUT "\n";
	       }
	       print OUT "\n"; # blank line after last prototype
	    }
	 } else {
	    print OUT;
	 }
      }

      close OUT;
      close IN;
      print STDERR "$File:$.: didn't write any prototypes\n" unless $blkno;
   }
   print STDERR "DIDN'T WRITE ANY PUBLIC PROTOTYPES!\n" unless $wrote_protos;
}

#
# Rename files.  Renamed only files that changed so make doesn't
# have to do so much work.  If $careful is set, then don't replace
# existing files.
#
sub rename_files {
   my (@files) = @_;
   my (@changed);

   print STDERR "Renaming files...\n";
   for $File (@files) {
      if (system "diff $File $File.pass3 >/dev/null") {
	 if ($careful) {
	    rename "$File.pass3", "$File.new";
	    unlink "$File.pass1";
	 } else {
	    rename $File, "$File.contrib";
	    rename "$File.pass3", $File;
	    unlink "$File.pass1";
	 }
	 push @changed, $File;
      } else {
	 unlink "$File.pass1", "$File.pass3";
      }
   }

   if (@changed) {
      if ($careful) {
	 print "The following new files were created:\n   ";
	 print join ".new\n   ", @changed;
	 print ".new\n";
      } else {
	 print "The following files have changed:\n   ";
	 print join "\n   ", @changed;
	 print "\n";
      }
   } else {
      if ($careful) {
	 print "No new files were created.\n";
      } else {
	 print "No files changed.\n";
      }
   }
}


pass1 @ARGV;
pass2 @ARGV;
pass3 @ARGV;
public_protos @ARGV;
rename_files @ARGV;
