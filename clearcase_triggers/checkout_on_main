#!/bin/sh

lines=`cat $0 | wc -l`
lines=`expr $lines - 15`
tail -$lines $0 > /tmp/runperl$$
echo "# $0 $*" >> /tmp/runperl$$
while [ $# -ne 0 ]
do
    line=$1
    shift
    totline="$totline\`$line"
done
exec perl /tmp/runperl$$ $0 $totline
echo Unable to run perl.  Check to see that perl is somewhere in your path.

# Perl begins here

unlink($0);

use Env;

# strippath separates a fully-expanded filename into its path and file
# parts.  If the fully-expanded filename does not have a path componenent, a
# NULL string is returned as the path.  The returned value is a list with the
# filename first and the path second, so that you can ignore the path if
# you like:
#           ($file) = &strippath($bigname);

sub strippath
{
    local($fullname) = @_;

    $fullname =~ m|^(.*/)?([^/]*)$|;
    ($path,$file) = ($1,$2);
    return($file,$path);
}

($0) = &strippath(shift);

$args = "@ARGV";
$args =~ s/^.//;
@ARGV = split('\`',$args);

# Real code begins here

$cleartool = "/usr/atria/bin/cleartool";

# Get the name of the new branch.
open(NB,"/home/meshtv/next_release_branch");
($full_new_release_branch,$new_release_label) = (<NB> =~ /^(\S+)\s+(\S+)/);
close(NB);
($new_release_branch) = ($full_new_release_branch =~ m|^/main/(.*)$|);

# Get the name of the current branch
open(NB,"/home/meshtv/current_release_branch");
($full_current_release_branch,$current_release_label) = (<NB> =~ /^(\S+)\s+(\S+)/);
close(NB);
($current_release_branch) = ($full_current_release_branch =~ m|^/main/(.*)$|);

# The file to check out is $CLEARCASE_XPN.  Check what branch it's being
# checkedout on.
$branch = "";
$branch = "main" if ($CLEARCASE_XPN =~ m|@@/main/\d+$|);
$branch = $new_release_branch
    if ($CLEARCASE_XPN =~ m|@@/main/$new_release_branch/\d+$|);
$branch = $current_release_branch
    if ($CLEARCASE_XPN =~ m|@@/main/$current_release_branch/\d+$|);
if ($branch eq "")
{
    # The checkout is on a branch other than the main/release branches.
    exit(0);
}

# Get the status of any lock that exists.
$lock_owner = "";
$users = "";
$users = `$cleartool lslock -fmt "%c" -brtype $branch`;
chop($users);
($lock_owner) = ($users =~ /^Locked except for users: (\w*)/);

# Check to see if the main/release branch is locked 
if ($lock_owner =~ /^\s*$/)
{
    # The main/release branch is not locked
    if ($branch eq "main")
    {
        print <<"EOF"

You are attempting to check out the file
"$CLEARCASE_PN"
on the "main" branch, but the "main" branch is not locked.
Please run the "lock_main" script to obtain a lock on the "main" branch before
proceeding.

You may see this message if you are using a "bugfix" view and have not locked 
the "bugfix" branch.  If this is the case, run the "lockbug" script to obtain 
a lock on the "bugfix" branch before proceeding.

EOF
    } elsif ($branch eq $new_release_branch)
    {
        print <<"EOF";

You are attempting to check out the file
"$CLEARCASE_PN"
on the "$branch" branch, but the "$branch" branch is not locked.
Please run the "locknew" script to obtain a lock on the
"$branch" branch before proceeding.

EOF
    } elsif ($branch eq $current_release_branch)
    {
        print <<"EOF";

You are attempting to check out the file
"$CLEARCASE_PN"
on the "$branch" branch, but the "$branch" branch is not locked.
Please run the "lockbug" script to obtain a lock on the
"$branch" branch before proceeding.

EOF
    }

    exit(1);
} else
{
    # The main/release branch is locked.  Check to see who it's locked to.

    if ($lock_owner !~ /^$CLEARCASE_USER$/)
    {
        # The main/release branch is locked to someone other than this person.
        print <<"EOF";
You are attempting to check out the file
"$CLEARCASE_PN"
on the "$branch" branch, but the "$branch" branch is already locked by
$lock_owner.

EOF

        exit(1);
    } 
}

# Everything's fine.  Allow the checkout.

exit(0);
