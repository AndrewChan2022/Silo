#include <mpi.h>
#include <pmpio.h>
#include <silo.h>
#include <string.h>
#include <stdlib.h>

/*-----------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     Callbacks 
 * Purpose:     Impliment the create callback
 *-----------------------------------------------------------------------------
 */
void *CreateSiloFile(const char *fname, const char *nsname, void *userData)
{
    DBfile *siloFile = DBCreate(fname, DB_CLOBBER, DB_LOCAL, "pmpio testing", DB_PDB);
    if (siloFile)
    {
        DBMkDir(siloFile, nsname);
        DBSetDir(siloFile, nsname);
    }
    return (void *) siloFile;
}

/*-----------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     Callbacks 
 * Purpose:     Impliment the open callback
 *-----------------------------------------------------------------------------
 */
void *OpenSiloFile(const char *fname, const char *nsname, PMPIO_iomode_t ioMode, void *userData)
{
    DBfile *siloFile = DBOpen(fname, DB_UNKNOWN,
        ioMode == PMPIO_WRITE ? DB_APPEND : DB_READ);
    if (siloFile)
    {
        if (ioMode == PMPIO_WRITE)
            DBMkDir(siloFile, nsname);
        DBSetDir(siloFile, nsname);
    }
    return (void *) siloFile;
}

/*-----------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     Callbacks 
 * Purpose:     Impliment the close callback
 *-----------------------------------------------------------------------------
 */
void CloseSiloFile(void *file, void *userData)
{
    DBfile *siloFile = (DBfile *) file;
    if (siloFile)
        DBClose(siloFile);
}

/*-----------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     Main 
 * Purpose:     Demonstrate use of PMPIO 
 * Description:
 * This simple program demonstrates the use of PMPIO to write a set of silo
 * files. Each processor will write a randomly sized array of at most 1024
 * intergers to its own sub-directory in a Silo file. By default, this program
 * will generate 3 silo files, regardless of the number of processors it is
 * run on. You can change the number of files generated by passing an integer
 * as an argument to the program. The following line will compile this example.
 *
 *     /usr/gapps/mpich/1.2.5/Linux/serial/64/debug/bin/mpicc -g -I. 
 *     -I/usr/gapps/silo/4.5.1/linux_rhel3_gcc_3.2.3/include
 *     pmpio_test.c -o pmpio_test
 *     -L/usr/gapps/silo/4.5.1/linux_rhel3_gcc_3.2.3/lib -lsilo -lm
 *
 *-----------------------------------------------------------------------------
 */
int main(int argc, char **argv)
{
    int size, rank;
    int numGroups = 3;
    DBfile *siloFile;
    char fileName[256], nsName[256];
    int i, dims[2], ndims = 2;
    char *coordnames[2];
    float *x, *y, *coords[2];

    if (argc >= 2)
        numGroups = atoi(argv[1]);

    MPI_Init(&argc, &argv);
    MPI_Comm_size(MPI_COMM_WORLD, &size);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    PMPIO_baton_t *bat = PMPIO_Init(numGroups, PMPIO_WRITE, MPI_COMM_WORLD, 1,
        CreateSiloFile, OpenSiloFile, CloseSiloFile, 0);

    sprintf(fileName, "silo_%03d", bat->groupRank);
    sprintf(nsName, "domain_%03d", bat->rankInComm);

    siloFile = (DBfile *) PMPIO_WaitForBaton(bat, fileName, nsName);

    /* define a very simple mesh to output */
    dims[0] = 2;
    dims[1] = size;
    coordnames[0] = "xcoords";
    coordnames[1] = "ycoords";
    x = (float *) malloc(2 * sizeof(float));
    x[0] = (float) rank;
    x[1] = (float) rank+1;
    y = (float *) malloc(size * sizeof(float));
    for (i = 0; i < size; i++)
        y[i] = (float) i;
    coords[0] = x;
    coords[1] = y;

    /* this processor's local work on the file */
    DBPutQuadmesh(siloFile, "qmesh", coordnames, coords, dims, ndims,
        DB_FLOAT, DB_COLLINEAR, 0);
    free(x);
    free(y);

    /* if this is the 'root' processor, build Silo's multi-XXX objects */
    if (rank == 0)
    {
        DBSetDir(siloFile, "/");
        char **blockNames = (char **) malloc(size * sizeof(char*));
        int *blockTypes = (int *) malloc(size * sizeof(int));
        for (i = 0; i < size; i++)
        {
            int groupRank = PMPIO_GroupRank(bat, i);
            blockNames[i] = (char *) malloc(1024);
            if (groupRank == 0)
            {
                /* this mesh block is in the file 'root' owns */
                sprintf(blockNames[i], "/domain_%03d/qmesh", i);
            }
            else
            {
                /* this mesh block is another file */ 
                sprintf(blockNames[i], "silo_%03d:/domain_%03d/qmesh", groupRank, i);
            }
            blockTypes[i] = DB_QUADMESH;
        }
        DBPutMultimesh(siloFile, "multi_qmesh",  size, blockNames, blockTypes, 0);
        for (i = 0; i < size; i++)
            free(blockNames[i]);
        free(blockNames);
        free(blockTypes);
    }

    PMPIO_HandOffBaton(bat, siloFile);

    PMPIO_Finish(bat);

    MPI_Finalize();

    return 0;
}
